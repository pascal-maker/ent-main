# Code generated by github.com/lolopinto/ent/ent, DO NOT edit. 


type Address implements Node {
    city: String!
    country: String!
    id: ID!
    residentNames: [String!]!
    state: String!
    streetAddress: String!
    zip: String!
}

input AddressCreateInput {
    city: String!
    country: String!
    residentNames: [String!]!
    state: String!
    streetAddress: String!
    zip: String!
}

type AddressCreateResponse {
    address: Address
}

input AddressDeleteInput {
    addressID: ID!
}

type AddressDeleteResponse {
    deletedAddressId: ID
}

input AddressEditInput {
    addressID: ID!
    city: String!
    country: String!
    residentNames: [String!]!
    state: String!
    streetAddress: String!
    zip: String!
}

type AddressEditResponse {
    address: Address
}

input AdminBlockInput {
    blockeeID: ID!
    blockerID: ID!
}

type AdminBlockResponse {
    success: Boolean
}

input AuthCheckAvailableEmailAddressInput {
    emailAddress: String!
}

type AuthCheckAvailableEmailAddressResponse {
    available: Boolean!
}

input AuthCheckAvailablePhoneNumberInput {
    phoneNumber: String!
}

type AuthCheckAvailablePhoneNumberResponse {
    available: Boolean!
}

input AuthEmailPasswordInput {
    email: String!
    password: String!
}

type AuthEmailPasswordResponse {
    token: String!
}

input AuthEmailTokenInput {
    token: String!
}

type AuthEmailTokenResponse {
    token: String!
}

input AuthPhoneNumberInput {
    phoneNumber: String!
    pin: String!
}

type AuthPhoneNumberResponse {
    token: String!
}

input AuthPhoneTokenInput {
    token: String!
}

type AuthPhoneTokenResponse {
    token: String!
}

input AuthSendSMSInput {
    phoneNumber: String!
}

type AuthSendSMSResponse {
    pin: String!
}

type AuthSignoutEmailResponse {
    success: Boolean
}

type AuthSignoutResponse {
    success: Boolean
}

input AuthUserInput {
    email: String!
    password: String!
}

type AuthUserResponse {
    token: String!
    user: User
}

type AuthUserResult {
    token: String!
    user: User
}

input AuthValidCredentialsInput {
    phoneNumber: String!
    pin: String!
}

type AuthValidCredentialsResponse {
    available: Boolean!
}

interface Connection {
    edges: [Edge!]
    nodes: [Node!]
}

type Contact implements Node {
    allowList: [User!]!
    contactBar(foo: Int!): Int!
    contactEmails: [ContactEmail!]!
    contactFoo: String!
    emailAddress: String!
    firstName: String!
    id: ID!
    lastName: String!
    user: User
}

input ContactCreateInput {
    emailAddress: String!
    favorite: Boolean
    firstName: String!
    lastName: String!
    numberOfCalls: Int
    pi: Float
    userID: String!
}

type ContactCreateResponse {
    contact: Contact
}

type ContactEmail implements Node {
    contact: Contact
    emailAddress: String!
    id: ID!
    label: String!
}

interface Edge {
    node: Node!
}

type Event implements Node {
    attending: [User!]!
    creator: User
    declined: [User!]!
    endTime: Time
    hosts: [User!]!
    id: ID!
    invited: [User!]!
    location: String!
    name: String!
    startTime: Time!
    user: User
    viewerRsvpStatus: EventRsvpStatus
}

input EventCreateInput {
    endTime: Time
    location: String!
    name: String!
    startTime: Time!
    userID: String!
}

type EventCreateResponse {
    event: Event
}

enum EventRsvpStatus {
    EVENT_ATTENDING
    EVENT_DECLINED
    EVENT_INVITED
    EVENT_UNKNOWN
}

input EventRsvpStatusEditInput {
    eventID: ID!
    rsvpStatus: String!
    userID: String!
}

type EventRsvpStatusEditResponse {
    event: Event
}

type EventsConnection implements Connection {
    edges: [EventsEdge!]
    nodes: [Event!]
}

type EventsEdge implements Edge {
    node: Event!
}

input LogEvent2Input {
    event: String!
}

type LogEvent2Response {
    success: Boolean
}

input LogEventInput {
    event: String!
}

type LogEventResponse {
    success: Boolean
}

type Mutation {
    addressCreate(input: AddressCreateInput!): AddressCreateResponse
    addressDelete(input: AddressDeleteInput!): AddressDeleteResponse
    addressEdit(input: AddressEditInput!): AddressEditResponse
    adminBlock(input: AdminBlockInput!): AdminBlockResponse
    authCheckAvailableEmailAddress(input: AuthCheckAvailableEmailAddressInput!): AuthCheckAvailableEmailAddressResponse
    authCheckAvailablePhoneNumber(input: AuthCheckAvailablePhoneNumberInput!): AuthCheckAvailablePhoneNumberResponse
    authEmailPassword(input: AuthEmailPasswordInput!): AuthEmailPasswordResponse
    authEmailToken(input: AuthEmailTokenInput!): AuthEmailTokenResponse
    authPhoneNumber(input: AuthPhoneNumberInput!): AuthPhoneNumberResponse
    authPhoneToken(input: AuthPhoneTokenInput!): AuthPhoneTokenResponse
    authSendSMS(input: AuthSendSMSInput!): AuthSendSMSResponse
    authSignout: AuthSignoutResponse
    authSignoutEmail: AuthSignoutEmailResponse
    authUser(input: AuthUserInput!): AuthUserResponse
    authValidCredentials(input: AuthValidCredentialsInput!): AuthValidCredentialsResponse
    contactCreate(input: ContactCreateInput!): ContactCreateResponse
    eventCreate(input: EventCreateInput!): EventCreateResponse
    eventRsvpStatusEdit(input: EventRsvpStatusEditInput!): EventRsvpStatusEditResponse
    logEvent(input: LogEventInput!): LogEventResponse
    logEvent2(input: LogEvent2Input!): LogEvent2Response
    userAddFamilyMember(input: UserAddFamilyMemberInput!): UserAddFamilyMemberResponse
    userAddFriend(input: UserAddFriendInput!): UserAddFriendResponse
    userCreate(input: UserCreateInput!): UserCreateResponse
    userDelete(input: UserDeleteInput!): UserDeleteResponse
    userEdit(input: UserEditInput!): UserEditResponse
    userRemoveFamilyMember(input: UserRemoveFamilyMemberInput!): UserRemoveFamilyMemberResponse
    userRemoveFriend(input: UserRemoveFriendInput!): UserRemoveFriendResponse
    viewerBlock(input: ViewerBlockInput!): ViewerBlockResponse
    viewerBlockMultiple(input: ViewerBlockMultipleInput!): ViewerBlockMultipleResponse
    viewerBlockMultipleIDs(input: ViewerBlockMultipleIDsInput!): ViewerBlockMultipleIDsResponse
    viewerBlockParam(userID: ID!): ViewerBlockParamResponse
}

interface Node {
    id: ID!
}

type Query {
    address(id: ID!): Address
    authUser(email: String!, password: String!): AuthUserResult
    contact(id: ID!): Contact
    contactEmail(id: ID!): ContactEmail
    event(id: ID!): Event
    serverTime: Time!
    user(id: ID!): User
    viewer: Viewer!
}

type User implements Node {
    baz: Float
    bio: String
    contacts: [Contact!]!
    declinedEvents: [Event!]!
    emailAddress: String!
    events: [Event!]!
    eventsAttending: [Event!]!
    familyMembers: [User!]!
    firstName: String!
    friends: [User!]!
    id: ID!
    invitedEvents: [Event!]!
    lastName: String!
    phoneNumber: String
    userFoo: String!
}

input UserAddFamilyMemberInput {
    familyMemberID: ID!
    userID: ID!
}

type UserAddFamilyMemberResponse {
    user: User
}

input UserAddFriendInput {
    friendID: ID!
    userID: ID!
}

type UserAddFriendResponse {
    user: User
}

input UserCreateInput {
    bio: String
    emailAddress: String!
    firstName: String!
    lastName: String!
    password: String!
    phoneNumber: String
}

type UserCreateResponse {
    user: User
}

input UserDeleteInput {
    userID: ID!
}

type UserDeleteResponse {
    deletedUserId: ID
}

input UserEditInput {
    bio: String
    firstName: String!
    lastName: String!
    userID: ID!
}

type UserEditResponse {
    user: User
}

input UserRemoveFamilyMemberInput {
    familyMemberID: ID!
    userID: ID!
}

type UserRemoveFamilyMemberResponse {
    user: User
}

input UserRemoveFriendInput {
    friendID: ID!
    userID: ID!
}

type UserRemoveFriendResponse {
    user: User
}

type UsersConnection implements Connection {
    edges: [UsersEdge!]
    nodes: [User!]
}

type UsersEdge implements Edge {
    node: User!
}

type Viewer {
    contact: Contact
    user: User!
}

input ViewerBlockInput {
    blockeeID: ID!
}

input ViewerBlockMultipleIDsInput {
    userIDs: [String!]!
}

type ViewerBlockMultipleIDsResponse {
    viewer: Viewer
}

input ViewerBlockMultipleInput {
    userIDs: [ID!]!
}

type ViewerBlockMultipleResponse {
    viewer: Viewer
}

type ViewerBlockParamResponse {
    viewer: Viewer
}

type ViewerBlockResponse {
    viewer: Viewer
}


scalar Time
